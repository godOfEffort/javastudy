# 디폴트 메서드
### 디폴트 메서드
인터페이스에 새로운 메서드를 추가할 경우 기존의 인터페이스를 구현한 클래스들에 모두 영향이 가게 된다.
이를 해결하는 방법은
첫째,인터페이스 내부에 정적 메서드를 사용
둘째,디폴트 메서드 사용
### 바이너리 호환성, 소스 호환성, 동작 호환성

1) 바이너리 호환성

뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황. 예를 들어 인터페이스에 메서드를 추가했을 때 추가된 메서드를 호출하지 않는 한
문제가 일어나지 않는데 이를 바이너리 호환성이라 한다.

2) 소스 호환성

코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 의미. 예를 들어 닡퍼에시으ㅔ 메서드를 추가하면
소스 호환성이 아니다. 추가한 메서드를 구현하도록 클래스를 고쳐야 하기 때문이다.

3) 동작 호환성

코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미. 예를 들어 
인터페이스에 메서드를 추가하더라도 프로그램에서 추가된 메서드를 호출할 일은 없으므로 동작 호환성은
유지된다.

### 디폴트 메서드란 무엇인가
인터페이스를 구현하는 클래스에서 구현하지 않은 메서드는 인터페이스 자체에서 기본으로 제공한다.
**함수형 인터페이스는 오직 하나의 추상메서드를 포함한다. 디폴트 메서드는 추상메서드에 해당하지 않는다.**

### 추상 클래스와 자바 8의 인터페이스

클래스는 하나의 추상클래스만 상속받을 수 있지만 인터페이스를 여러 개 구현할 수 있다.

추상 클래스는 인스턴스 변수(필드)로 공통상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다.

### 디폴트 메서드 활용 패턴

1) 선택형 메서드

자바 8 이전에는 Iterator 인터페이스의 remove 메서드를 무시했다. 결과적으로 Iterator를 구현하는
많은 클래스에서는 remove에 빈 구현을 제공했다. 

그러나 디폴트 메서드를 이용하면 remove 같은 메서드에 기본 구현을 제공할 수 있으므로 인터페이스를 구현하는
클래스에서 빈 구현을 제공할 필요가 없다. 

### 동작 다중 상속

자바에서 클래스는 한 개의 다른 클래스만 상속할 수 있지만 인터페이스는 여러 개 구현할 수 있다.
```java
    public class ArrayList<E> extends AbstracList<E> implements List<E>, RandomAccess, Cloneable, Serializable{
        
    }
```

1) 기능이 중복되지 않는 최소의 인터페이스

```java
public interface Rotatable {
    void setRotationAngle(int angleInDegress);
    int getRotationAngle();
    default void rotateBy(int angleInDegress) {
        setRotateAngle(getRotationAngle() + angleInDegress % 360);
    }
}
```

rotateBy는 기본 구현이 제공되므로 따로 구현을 제공하지 않아도 된다.

2) 인터페이스 조합
인터페이스를 조합해서 다양한 클래스를 구현할 수 있다. 디폴트 메서드의 구현은 제공할 필요가 없다.


3) 옳지 못한 상속

상속으로 코드 재사용 문제를 모두 해결할 수 없다. 예를 들어 한 개의 메서드를 재사용하려고
100개의 메서드와 필드가 정의되어 있는 클래스를 상속받는 것은 좋은 생각이 아니다. 이럴 때는
델리게이션, 즉 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를
작성하는 것이 좋다.

### 해석 규칙

자바의 클래스는 하나의 부모 클래스만 상속받을 수 있지만 여러 인터페이스를 동시에 구현할 수 있다.
디폴트 메서드가 추가되었으므로 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길 수 있다.
아래와 같은 상황이다.

```java
    public interface A {
        default void hello(){
            System.out.println("Hello from A");
        }   
    }

    public interface B extends A {
        default void hello(){
            System.out.println("Hello from B");
        }   
    }

    public class C implements A, B {
        public static void main(String[] args){
          new C().hello();
        }
    }
```

### 알아야 할 세가지 해결 규칙
1. 
